

# ü§ñ OutSystems AI Butler

**The missing link between Service Studio, Architecture Canvas, and Large Language Models.**

OutSystems AI Butler acts as a **"Digital Twin"** and **Architecture Governance Tool** for your OutSystems environment (O11 or ODC). It bridges the gap between visual low-code development, rigid architectural standards, and text-based AI models (like ChatGPT, Claude, or DeepSeek).

By maintaining a structured mirror of your **Data**, **Logic**, **UI**, and **Module Dependencies** locally, this tool allows you to:

1. **Visualize & Validate** your architecture against OutSystems best practices.
2. **Export** token-efficient, hallucination-free context for AI.
3. **Import** AI-generated code back into your workflow using compatible schemas.

---

## üåü Why use this?

LLMs are great at writing code, but they often fail at understanding **context** and **architecture**.

* **The Problem:** You ask an AI to "create a logic flow," but it invents tables that don't exist, references modules that create circular dependencies, or suggests placing core logic in the frontend layer.
* **The Solution:** Butler provides the AI with a **strict JSON definition** of your entire project structure. The AI "sees" your entities, your available actions, and your layer rules, ensuring its output is valid and architecturally sound.

---

## üöÄ Key Features

### üèõÔ∏è Architecture & Governance (NEW)

The app implements a real-time **Architecture Canvas** validator that enforces the **OutSystems 3-Layer Rules**:

1. **Orchestration & Visualization:** Modules are visually grouped into **End-User**, **Core**, and **Foundation** layers.
2. **Intelligent Dependency Graph:** Arrows are drawn automatically between modules:
* **Gray Orthogonal Lines:** Valid references.
* **Red Loop-Around Lines:** Invalid references (Violations).


3. **Real-Time Validation:** The "Governance Box" warns you immediately if you break a rule:
* ‚ùå **No Upward References:** A Core module cannot consume an End-User module.
* ‚ùå **No Side References (Top Layers):** End-User modules cannot consume each other.
* ‚ùå **No Circular Dependencies:** A module cannot indirectly depend on itself.



### üì¶ "Deep" Dependency Management

Unlike standard diagrams that just show "Module A uses Module B," Butler tracks **Granular Dependencies**:

* **Precision:** You select exactly *which* **Entities**, **Actions**, or **Screens** are consumed from a producer module.
* **Context:** This granular data is fed to the LLM, so it knows *why* a dependency exists (e.g., "This module consumes `Order_CS` specifically for the `CreateOrder` action").

### ‚ö° Full-Stack Digital Twin

* **Data Layer:** Define Entities, Attributes, and Relationships. Auto-generates ERDs.
* **Logic Layer:** Visual Flowchart editor for Server Actions (Ifs, Loops, SQL, JS).
* **UI Layer:** Define Screens and Blocks to map out your frontend.

### ü§ñ AI Integration

* **Prompt Templates:** Built-in prompts to teach the AI how to read your specific architecture.
* **One-Click Context:** Generates a highly optimized JSON prompt of your module (or the entire project) to paste into ChatGPT.

---

## üíæ Export & Import Ecosystem

This application supports two distinct types of data exchange: **Full Project Snapshots** and **Code Snippets**.

### 1. Full Project Backup (`.butler` JSON)

Use the **"Export Project"** button on the main dashboard to generate a `.butler` file.

* **What it contains:** The entire project graph. Every Module, Entity, Action, UI Element, Description, and‚Äîcrucially‚Äîthe **Dependency Links** between them.
* **Use Case:** Backups, sharing architecture with teammates, or feeding an **entire project context** to a very large context window LLM (like Claude 3 Opus or Gemini 1.5 Pro).
* **Smart Import:** When importing a project, the system performs a **"Deep Remap"**: it regenerates UUIDs for every element but preserves the internal relationships, ensuring the dependency arrows still point to the correct modules in the new copy.

### 2. Code Snippet Import (XML)

Use the **"üìã Import"** button inside a module to inject specific logic or data.

* **Format:** A simplified XML schema based on the clipboard format.
* **Use Case:** Taking a specific Action or Entity generated by ChatGPT and injecting it into your current module.

---

## üõ†Ô∏è Installation

### Prerequisites

* **Node.js** (v18 or higher)
* **npm** (included with Node.js)

### Steps

1. **Clone the Repository**
```bash
git clone https://github.com/fabianluz/outsystems-ai-butler
cd outsystems-ai-butler

```


2. **Install Dependencies**
```bash
npm install
# Critical: Ensure graph and visualization libraries are installed
npm install dagre @types/dagre @xyflow/react uuid dexie

```


3. **Start the Application**
```bash
npm run dev

```


4. **Open in Browser**
Navigate to `http://localhost:5173`.

---

## üìñ The "Architecture-First" Workflow

### Phase 1: Canvas Definition

1. Create your modules and assign them to **Layers** (End-User, Core, Foundation).
2. Use the **Dependency Inspector** (Info icon on module cards) to define relationships.
3. Check the **Governance Box** at the top of the screen. If it's green ("The architecture canvas looks correct"), proceed. If it's red, fix the arrows.

### Phase 2: Context Generation

1. Enter a module.
2. Define your Entities and Actions (or import them).
3. Click **"‚ú® Copy for AI"**. This copies a JSON payload containing:
* The module's schema.
* **Architecture Context:** Which layer it is in and what it is allowed to see.
* **Dependency Context:** Exact signatures of Actions/Entities available from other modules.



### Phase 3: AI Development

1. Paste the context into ChatGPT.
2. Ask: *"Create a Server Action that uses the 'CreateOrder' dependency to save data, but validate the 'CustomerStatus' first."*
3. The AI will use the **exact names** of your dependencies because they were provided in the context.

---

## üìÑ XML Schema for AI Interaction

When asking an LLM to generate code for Butler, you can reference this structure:

### Entities

```xml
<Entity Name="Customer" Description="Core Profile">
    <Attributes>
        <EntityAttribute Name="Id" Type="LongInteger" IsIdentifier="true" />
        <EntityAttribute Name="Email" Type="Email" IsMandatory="true" />
    </Attributes>
</Entity>

```

### Server Actions

```xml
<ServerAction Name="ProcessOrder">
    <InputParameter Name="OrderId" Type="LongInteger" />
    <Flow>
        <Start Name="Start" />
        <SQL Name="GetTotal" SQL="SELECT Total FROM Orders WHERE Id = @OrderId" />
        <If Name="IsHighValue">
            <Condition>GetTotal.List.Current.Total > 1000</Condition>
        </If>
        <End Name="End" />
        <Link Source="Start" Target="GetTotal" />
        <Link Source="GetTotal" Target="IsHighValue" />
        <Link Source="IsHighValue" Target="End" Label="True" />
    </Flow>
</ServerAction>

```